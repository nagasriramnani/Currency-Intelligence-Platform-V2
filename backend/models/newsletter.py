"""
Newsletter Pydantic Models

Defines request/response schemas for the newsletter subscription system.
"""

from pydantic import BaseModel, Field, EmailStr, field_validator
from typing import Optional, List
from datetime import datetime
from enum import Enum
import re


class FrequencyEnum(str, Enum):
    """Newsletter frequency options"""
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    NOW = "now"  # Send immediately


# =============================================================================
# Subscription Models
# =============================================================================

class SubscriptionCreate(BaseModel):
    """Request model for creating/updating a subscription"""
    email: EmailStr = Field(..., description="Subscriber email address")
    frequency: FrequencyEnum = Field(
        default=FrequencyEnum.WEEKLY,
        description="Newsletter frequency"
    )
    
    @field_validator('email')
    @classmethod
    def normalize_email(cls, v: str) -> str:
        return v.lower().strip()


class SubscriptionResponse(BaseModel):
    """Response model for subscription operations"""
    success: bool
    message: str
    subscription_id: Optional[str] = None
    email: Optional[str] = None
    frequency: Optional[str] = None
    is_active: Optional[bool] = None


class SubscriptionRecord(BaseModel):
    """Database record for a subscription"""
    id: str
    email: str
    frequency: str
    created_at: datetime
    last_sent_at: Optional[datetime] = None
    is_active: bool = True


# =============================================================================
# Newsletter Run Models
# =============================================================================

class RunStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    ERROR = "error"


class NewsletterRunCreate(BaseModel):
    """Request to trigger a newsletter run"""
    frequency: FrequencyEnum = Field(..., description="Which subscribers to target")
    

class NewsletterRunResponse(BaseModel):
    """Response for newsletter run status"""
    success: bool
    run_id: Optional[str] = None
    status: str
    subscribers_count: int = 0
    emails_sent: int = 0
    message: Optional[str] = None
    error: Optional[str] = None


class NewsletterRunRecord(BaseModel):
    """Database record for a newsletter run"""
    id: str
    frequency: str
    run_at: datetime
    status: str
    subscribers_count: int = 0
    emails_sent: int = 0
    error_message: Optional[str] = None
    llm_response: Optional[str] = None
    completed_at: Optional[datetime] = None


# =============================================================================
# Company Summary (for newsletter content)
# =============================================================================

class CompanySummary(BaseModel):
    """Company data for newsletter inclusion"""
    company_number: str
    company_name: str
    eis_score: int = 0
    eis_status: str = "Unknown"
    sector: str = "Diversified"
    revenue: Optional[str] = None
    news_summary: Optional[str] = None
    news_sources: Optional[List[str]] = None
    recommended_action: Optional[str] = None


# =============================================================================
# Newsletter Content (LLM-generated)
# =============================================================================

# Banned phrases for safety validation
BANNED_PHRASES = [
    "guaranteed tax relief",
    "hmrc approved this investment",
    "hmrc has approved",
    "certain to qualify for eis",
    "guaranteed returns",
    "risk-free investment",
    "hmrc endorses",
    "tax-free guaranteed"
]


def _check_banned_phrases(value: str) -> str:
    """Check for prohibited phrases that could cause compliance issues"""
    lower_v = value.lower()
    for phrase in BANNED_PHRASES:
        if phrase in lower_v:
            raise ValueError(f"Content contains prohibited phrase: '{phrase}'")
    return value


class NewsletterContent(BaseModel):
    """
    Structured content generated by Ollama for the newsletter.
    Falls back to template if LLM parsing fails.
    """
    subject: str = Field(..., max_length=100, description="Email subject line")
    preview_text: str = Field(..., max_length=200, description="Email preview/preheader")
    text_body: str = Field(..., description="Plain text version")
    html_body: str = Field(..., description="HTML formatted version")
    ai_generated: bool = True
    
    @field_validator('subject', 'preview_text', 'text_body', 'html_body')
    @classmethod
    def check_safety(cls, v: str) -> str:
        return _check_banned_phrases(v)


class NewsletterTestRequest(BaseModel):
    """Request to send a test newsletter"""
    email: EmailStr = Field(..., description="Recipient email")
    portfolio_companies: Optional[List[CompanySummary]] = Field(
        default=None,
        description="Companies to include (uses defaults if not provided)"
    )


class NewsletterTestResponse(BaseModel):
    """Response for test newsletter send"""
    success: bool
    message: str
    email: str
    companies_included: int = 0


# =============================================================================
# Internal Run Request (for cron/scheduler)
# =============================================================================

class InternalRunRequest(BaseModel):
    """Request model for internal newsletter run (cron-triggered)"""
    frequency: FrequencyEnum
    max_subscribers: int = Field(
        default=50, 
        ge=1, 
        le=500,
        description="Max subscribers per run (safety limit)"
    )
    dry_run: bool = Field(
        default=False,
        description="If true, generate content but don't send emails"
    )
